// Generated by CoffeeScript 1.4.0
(function() {
  var CoffeeScript, ContentBuilder, fs;

  fs = require("fs");

  CoffeeScript = require("coffee-script");

  /*
  ManifestContent builder provides an interface 
  for you to read a simple manifest file 
  and generate the aggregated content as output.
  */


  ContentBuilder = (function() {

    ContentBuilder.prototype.filters = [];

    ContentBuilder.prototype.finalizeFilters = [];

    ContentBuilder.prototype.contentList = [];

    ContentBuilder.prototype.options = {};

    function ContentBuilder(file, options) {
      this.options = options;
      this.rawContent = fs.readFileSync(file, "utf8");
      this.contentList = this.rawContent.split(/\n/);
      this.options || (this.options = {});
      this.useDefaultFilters();
    }

    ContentBuilder.prototype.useDefaultFilters = function() {
      this.addFilter(/\.js$/, function(file) {
        return fs.readFileSync(file, "utf8");
      });
      this.addFilter(/\.coffee/, function(file) {
        return CoffeeScript.compile(fs.readFileSync(file, "utf8"), {
          bare: true
        });
      });
      return this;
    };

    /*
      A filter is registered with a pattern and a callback, 
      The callback takes a file path and should returns filtered content.
    */


    ContentBuilder.prototype.addFilter = function(pattern, filter) {
      return this.filters.push({
        pattern: pattern,
        filter: filter
      });
    };

    /* 
    A finalize filter takes content in string and returns filtered content.
    */


    ContentBuilder.prototype.addFinalizeFilter = function(filter) {
      return this.finalizeFilters.push(filter);
    };

    ContentBuilder.prototype.list = function(filter) {
      var filterComments, list, stripComments,
        _this = this;
      filterComments = function(line) {
        if (!line)  
          return false;
        if (line.match(/^\s*#/))  
          return false;
        return true;
      };
      stripComments = function(line) {
        return line.replace(/#.*/, "");
      };
      list = this.contentList.filter(filterComments).map(stripComments).map(function(file) {
        if (_this.options.baseDir) {
          return _this.options.baseDir + "/" + file; 
        } else {
          return file;
        }
      });
      if (!filter)  
        return list;
      if (filter instanceof RegExp)  
        return list.filter(function(item) {
          return item.match(filter);
        });
      if (filter instanceof Function)  
        return list.filter(filter);
    };

    /*
      Compile manifest to content through these registered filters.
      returns content string.
    */


    ContentBuilder.prototype.compile = function() {
      var content, f, file, line, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      content = "";
      _ref = this.contentList;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        if (!line) {
          continue; 
        }
        if (line.match(/^\s*#/)) {
          continue; 
        }
        file = line.replace(/#.*/, "");
        if (this.options.baseDir)  
          file = this.options.baseDir + "/" + file;
        if (!fs.existsSync(file)) {
          console.warn("File " + file + " does not exist.");
          continue; 
        }
        console.log("  Compiling " + file + "...");
        _ref1 = this.filters;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          f = _ref1[_j];
          if (file.match(f.pattern)) {
            content += f.filter(file);
            break; 
          }
        }
      }
      _ref2 = this.finalizeFilters;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        f = _ref2[_k];
        content = f(content);
      }
      return content;
    };

    return ContentBuilder;

  })();

  module.exports = ContentBuilder;

}).call(this);
